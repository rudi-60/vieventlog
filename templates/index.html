<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ViEventLog - Viessmann Event Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
            min-height: 100vh;
            padding: 0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #1e1e2e 0%, #262637 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px 30px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .header-link {
            background: rgba(255,255,255,0.05);
            color: #a0a0b0;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 14px;
            transition: all 0.2s;
        }

        .header-link:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border-color: rgba(255,255,255,0.2);
        }

        h1 {
            color: #fff;
            font-size: 24px;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 14px;
            color: #a0a0b0;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
        }

        .status-dot.connected {
            background: #10b981;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .controls {
            background: linear-gradient(135deg, #1e1e2e 0%, #262637 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px 30px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-size: 14px;
            color: #e0e0e0;
            font-weight: 500;
        }

        select, input {
            padding: 8px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            font-size: 14px;
            background: rgba(255,255,255,0.05);
            color: #e0e0e0;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255,255,255,0.08);
        }

        select option {
            background: #1e1e2e;
            color: #e0e0e0;
        }

        select optgroup {
            background: #262637;
            color: #fff;
            font-weight: 600;
            font-style: normal;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b41a0 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: rgba(255,255,255,0.1);
            cursor: not-allowed;
            border-color: rgba(255,255,255,0.1);
            box-shadow: none;
        }

        .events-container {
            background: linear-gradient(135deg, #1e1e2e 0%, #262637 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .events-header {
            background: rgba(0,0,0,0.2);
            padding: 15px 30px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .events-header h2 {
            color: #fff;
        }

        .event-count {
            font-size: 14px;
            color: #a0a0b0;
        }

        .events-list {
            max-height: 600px;
            overflow-y: auto;
        }

        .event-item {
            padding: 15px 30px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            transition: background 0.2s;
            cursor: pointer;
        }

        .event-item:hover {
            background: rgba(255,255,255,0.05);
        }

        .event-item.expanded {
            background: rgba(255,255,255,0.08);
        }

        .event-header {
            display: grid;
            grid-template-columns: 180px 1fr auto;
            gap: 20px;
            align-items: center;
        }

        .event-time {
            font-size: 13px;
            color: #a0a0b0;
            font-family: 'Monaco', 'Courier New', monospace;
        }

        .event-type {
            font-size: 14px;
            font-weight: 500;
            color: #e0e0e0;
        }

        .event-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            background: #edf2f7;
            color: #4a5568;
        }

        .event-badge.error {
            background: #fed7d7;
            color: #c53030;
        }

        .event-badge.warning {
            background: #feebc8;
            color: #c05621;
        }

        .event-badge.info {
            background: #bee3f8;
            color: #2c5282;
        }

        .event-badge.status {
            background: #c6f6d5;
            color: #276749;
        }

        .event-badge.fault {
            background: #fed7d7;
            color: #c53030;
        }

        .code-description {
            font-size: 13px;
            color: #b0b0c0;
            margin-top: 4px;
            font-style: italic;
        }

        .device-info {
            font-size: 12px;
            color: #a0a0b0;
            display: inline-block;
            padding: 2px 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            margin-left: 8px;
        }

        .event-details {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 5px;
            font-size: 13px;
            font-family: 'Monaco', 'Courier New', monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            display: none;
            max-height: 300px;
            overflow-y: auto;
            color: #b0b0c0;
        }

        .event-item.expanded .event-details {
            display: block;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #a0a0b0;
        }

        .loading-spinner {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(254, 215, 215, 0.1);
            color: #ff6b6b;
            border: 1px solid rgba(197, 48, 48, 0.3);
            padding: 15px 30px;
            border-radius: 5px;
            margin: 20px 0;
        }

        .filter-input {
            padding: 8px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            font-size: 14px;
            width: 200px;
            background: rgba(255,255,255,0.05);
            color: #e0e0e0;
        }

        .no-events {
            text-align: center;
            padding: 60px;
            color: #a0a0b0;
        }

        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                max-width: 100%;
            }

            header {
                padding: 15px;
                border-radius: 8px;
            }

            .header-top {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }

            .header-top > div:last-child {
                display: flex;
                flex-direction: column;
                gap: 8px;
                width: 100%;
            }

            h1 {
                font-size: 20px;
            }

            .status {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                font-size: 13px;
            }

            .controls {
                padding: 15px;
                gap: 12px;
                border-radius: 8px;
            }

            .control-group {
                flex-direction: column;
                align-items: stretch;
                width: 100%;
                gap: 5px;
            }

            select, input, .filter-input {
                width: 100%;
                font-size: 16px; /* Prevents zoom on iOS */
            }

            button {
                width: 100%;
                padding: 12px 20px;
                font-size: 15px;
            }

            .timeline-container {
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 15px;
            }

            .timeline-container h2 {
                font-size: 18px;
            }

            .timeline-container p {
                font-size: 11px;
            }

            #timelineControls {
                gap: 6px;
            }

            #timelineControls button {
                padding: 6px 10px;
                font-size: 11px;
                width: auto;
            }

            #timeline {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                min-height: 0;
            }

            /* Fix timeline SVG width for mobile */
            #timeline svg {
                max-width: none;
                height: auto;
            }

            /* Make timeline chart responsive on mobile */
            .timeline-container {
                overflow-x: auto;
            }

            .events-container {
                border-radius: 8px;
            }

            .events-header {
                padding: 12px 15px;
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .events-header h2 {
                font-size: 18px;
            }

            .event-count {
                font-size: 13px;
            }

            .events-list {
                max-height: 500px;
            }

            .event-item {
                padding: 12px 15px;
            }

            .event-header {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .event-time {
                font-size: 12px;
            }

            .event-type {
                font-size: 13px;
            }

            .device-info {
                display: block;
                margin: 5px 0;
            }

            .event-badge {
                font-size: 11px;
                padding: 3px 10px;
            }

            .code-description {
                font-size: 12px;
                margin-top: 6px;
            }

            .event-details {
                font-size: 12px;
                max-height: 200px;
                padding: 12px;
            }

            .loading {
                padding: 30px;
            }

            .loading-spinner {
                width: 30px;
                height: 30px;
            }

            .no-events {
                padding: 40px 20px;
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            h1 {
                font-size: 18px;
            }

            .header-top > div:last-child {
                font-size: 12px;
            }

            .header-link {
                padding: 6px 12px;
                font-size: 13px;
            }

            .controls {
                padding: 12px;
            }

            button {
                padding: 10px 16px;
                font-size: 14px;
            }

            #timelineControls button {
                padding: 5px 8px;
                font-size: 10px;
            }

            #saveFiltersBtn, #resetFiltersBtn {
                padding: 5px 8px !important;
                font-size: 10px !important;
            }

            .timeline-container h2 {
                font-size: 16px;
            }

            .event-item {
                padding: 10px 12px;
            }

            .event-type {
                font-size: 12px;
            }

            .event-time {
                font-size: 11px;
            }
        }
    </style>
    <!-- ECharts 6.0.0 and Luxon 3.7.2 (embedded in binary) -->
    <script src="/static/js/echarts.min.js"></script>
    <script src="/static/js/luxon.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-top">
                <div>
                    <h1 style="display: inline;">ViEventLog</h1>
                    {{if .Version}}
                    <span style="font-size: 11px; color: #666; margin-left: 10px; font-family: monospace;">{{.Version}}</span>
                    {{end}}
                </div>
                <div style="display: flex; gap: 10px;">
                    <a href="/smartclimate" class="header-link">üè† SmartClimate</a>
                    <a href="/vitovent" class="header-link">üå¨Ô∏è Vitovent</a>
                    <a href="/vitocharge" class="header-link">‚ö° Vitocharge</a>
                    <a href="/accounts" class="header-link">‚öôÔ∏è Account-Verwaltung</a>
                    <a href="/apitest" class="header-link">üîß API Test</a>
                </div>
            </div>
            <div class="status">
                <div class="status-indicator">
                    <span class="status-dot" id="statusDot"></span>
                    <span id="statusText">Verbinde...</span>
                </div>
                <div id="lastFetch"></div>
                <div id="deviceInfo"></div>
            </div>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>Zeitraum:</label>
                <select id="daysSelect">
                    <option value="0.25">Letzte 6 Stunden</option>
                    <option value="1" selected>Letzte 24 Stunden</option>
                    <option value="3">Letzte 3 Tage</option>
                    <option value="7">Letzte 7 Tage</option>
                    <option value="14">Letzte 14 Tage</option>
                    <option value="30">Letzte 30 Tage</option>
                    <option value="90">Letzte 90 Tage</option>
                    <option value="365">Alle (1 Jahr)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Ger√§t:</label>
                <select id="deviceSelect">
                    <option value="all">Alle Ger√§te</option>
                </select>
            </div>

            <div class="control-group">
                <label>Filter:</label>
                <input type="text" id="filterInput" class="filter-input" placeholder="Event-Typ oder Code filtern...">
            </div>

            <div class="control-group">
                <label>Typ:</label>
                <select id="typeFilter">
                    <option value="all">Alle</option>
                    <option value="status">Status (S-Codes)</option>
                    <option value="fault">Fehler (F-Codes)</option>
                    <option value="active">Aktive Events</option>
                </select>
            </div>

            <button id="refreshBtn" onclick="loadEvents()">
                Aktualisieren
            </button>

            <button id="autoRefreshBtn" onclick="toggleAutoRefresh()">
                Auto-Refresh: Aus
            </button>

            <button id="exportBtn" onclick="exportEvents()" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">
                üíæ Export Events
            </button>

            <button id="dashboardBtn" onclick="openDashboard()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                üìä Dashboard
            </button>
        </div>

        <!-- Timeline Visualization -->
        <div class="timeline-container" style="background: linear-gradient(to bottom, #1e1e2e 0%, #262637 100%); border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); padding: 24px; margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.1); overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div>
                    <h2 style="margin: 0; font-size: 20px; color: #fff; font-weight: 600; display: flex; align-items: center; gap: 10px;">
                        <span style="display: inline-block; width: 4px; height: 20px; background: linear-gradient(to bottom, #667eea, #764ba2); border-radius: 2px;"></span>
                        Event Timeline
                    </h2>
                    <p style="margin: 5px 0 0 14px; font-size: 12px; color: #a0a0b0;">Visualisierung der Betriebszust√§nde</p>
                </div>
                <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                    <button id="saveFiltersBtn" onclick="saveTimelineFilters()"
                            style="padding: 7px 13px; border: 1px solid rgba(255,255,255,0.3);
                                   background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
                                   color: white; border-radius: 6px; cursor: pointer; font-size: 12px;
                                   font-weight: 500; transition: all 0.2s; display: inline-flex;
                                   align-items: center; gap: 6px; box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);"
                            title="Aktuelle Timeline-Filter-Auswahl im Browser speichern">
                        üíæ Auswahl speichern
                    </button>
                    <button id="resetFiltersBtn" onclick="resetTimelineFilters()"
                            style="padding: 7px 13px; border: 1px solid rgba(255,255,255,0.2);
                                   background: rgba(255,255,255,0.05);
                                   color: #a0a0b0; border-radius: 6px; cursor: pointer; font-size: 12px;
                                   font-weight: 500; transition: all 0.2s; display: inline-flex;
                                   align-items: center; gap: 6px;"
                            title="Timeline-Filter auf Standardwerte zur√ºcksetzen">
                        üîÑ Reset
                    </button>
                    <div id="timelineControls" style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <!-- Filter buttons will be added here -->
                    </div>
                </div>
            </div>
            <div id="timeline" style="width: 100%; overflow-x: auto; overflow-y: hidden; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px;"></div>
        </div>

        <div class="events-container">
            <div class="events-header">
                <h2>Events</h2>
                <button id="resetZoomBtn" onclick="resetTimelineZoom()"
                        style="padding: 7px 13px; border: 1px solid rgba(255,255,255,0.2);
                               background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                               color: white; border-radius: 6px; cursor: pointer; font-size: 12px;
                               font-weight: 500; transition: all 0.2s; display: none;
                               align-items: center; gap: 6px; box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
                               margin-left: 10px;"
                        title="Zoom zur√ºcksetzen und alle Events anzeigen">
                    üîÑ Alle Events anzeigen
                </button>
                <div class="event-count" id="eventCount">0 Events</div>
            </div>
            <div class="events-list" id="eventsList">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div>Lade Events...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state management
        let allEvents = [];
        let installations = {};
        let autoRefreshInterval = null;
        let autoRefreshEnabled = false;

        // Pagination state
        let displayedEventCount = 100; // Initial: show 100 events
        const eventsPerPage = 100; // Load 100 more each time

        // Centralized filter state
        let globalFilters = {
            // Zeitraum filter (determines API call AND display for both views)
            days: 1, // Default: Last 24 hours (365, 90, 30, 14, 7, 3, 1)

            // Client-side filters (filter loaded events)
            device: 'all',
            type: 'all',
            search: '',

            // Timeline event type filters
            timelineTypes: {
                'S.123': true,  // W√§rmepumpe Aus
                'S.124': true,  // W√§rmepumpe Vorlaufphase
                'S.125': true,  // W√§rmepumpe Heizen
                'S.125-WARMWATER': true,  // W√§rmepumpe Warmwasserbereitung
                'S.126': true,  // W√§rmepumpe K√ºhlen
                'S.127': true,  // W√§rmepumpe Abtauen vorbereiten
                'S.128': true,  // W√§rmepumpe Abtauen
                'S.129': true,  // W√§rmepumpe Nachlaufphase
                'S.112': true,  // Initialisierung 4/3-Wege-Ventil
                'S.113': true,  // 4/3-Wege-Ventil schaltet -> Trinkwasser
                'S.114': true,  // 4/3-Wege-Ventil schaltet -> Heiz-/K√ºhlkreis 1
                'S.115': true,  // 4/3-Wege Ventil Position Trinkwasser
                'S.116': true,  // 4/3-Wege Ventil Position Heiz-/K√ºhlkreis 1
                'S.117': true,  // 4/3-Wege Ventil Position Heiz-/K√ºhlkreis 2
                'S.118': true,  // 4/3-Wege Ventil Position Pufferspeicher
                'S.134': true,  // 4/3-Wege Ventil Leerlauf
                'S.135': true,  // 4/3-Wege Ventil Abtauen
                'S.136': true,  // 4/3-Wege Ventil Raumbeheizung/Raumk√ºhlung
                'S.168': true,  // L√ºftungsbypass offen
                'S.169': true,  // L√ºftungsbypass geschlossen
                'I.120': true,  // Silentmode - Ger√§uschreduzierter Betrieb
                'I.121': true,  // Feuchteanbauschalter Heiz-/K√ºhlkreis 1 aktiv
                'I.122': true,  // Feuchteanbauschalter Heiz-/K√ºhlkreis 2 aktiv
                'I.135': true,  // Abtauen aktiv im Regelbetrieb
                'S.176': true,  // W√§rmepumpenregelung: Abtauen angefordert
                'S.187': true,  // Passiver Frostschutz W√§rmepumpe
                'S.427': true,  // Leistungsbegrenzung durch Netzbetreiber
                'S.432': true,  // Abtauung des L√ºfters aktiv
                'S.131': true,  // Heizwasser-Durchlauferhitzer: Stufe 1 aktiv
                'S.132': true,  // Heizwasser-Durchlauferhitzer: Stufe 2 aktiv
                'S.133': true,  // Heizwasser-Durchlauferhitzer: Stufe 3 aktiv
                // Gateway/Point Events (Einzelevents ohne Zeitspanne)
                'gateway-online': true,  // Gateway wieder online
                'gateway-offline': true,  // Gateway offline
                'feature-changed': true,  // Feature wurde ge√§ndert
                'firmware-update-status': true,  // Firmware-Update Status
                'other': true
            },

            // Blacklist: Events that should never be shown in timeline
            timelineBlacklist: [
                'S.1',    // Anlage eingeschaltet
                'S.217',  // Heizwasser-Durchlauferhitzer: Stufe 1 inaktiv
                'S.218',  // Heizwasser-Durchlauferhitzer: Stufe 2 inaktiv
                'S.219'   // Heizwasser-Durchlauferhitzer: Stufe 3 inaktiv
                // Weitere "inaktiv" Events (bei Bedarf aktivieren):
                // 'S.139',  // Heizbetrieb inaktiv
                // 'S.142',  // Trinkwassererwaermung inaktiv
                // 'S.145',  // Kuehlbetrieb inaktiv
                // 'S.149',  // Abtauen ueber Waermepumpe inaktiv
                // 'S.152',  // Abtauen ueber Heiz-/Kuehlkreis inaktiv
                // 'S.163'   // Waermepumpe: Systemstatus inaktiv
            ],

            // Timeline zoom range filter (set by ECharts dataZoom)
            timeRange: null  // { start: timestamp, end: timestamp } or null for all
        };

        // ========================================
        // HELPER FUNCTIONS
        // ========================================

        /**
         * Format timestamp to local timezone
         * Converts RFC3339/ISO timestamp to browser's local time
         */
        function formatTimestamp(timestamp) {
            if (!timestamp) return 'N/A';
            try {
                const date = new Date(timestamp);
                return date.toLocaleString('de-DE', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            } catch (e) {
                return timestamp;
            }
        }

        function categorizeEvent(event) {
            // Use the category from backend if available
            if (event.codeCategory === 'fault') return 'fault';
            if (event.codeCategory === 'status') return 'status';

            // Fallback to eventType-based categorization
            const eventType = event.eventType || '';
            const errorPatterns = ['error', 'fail', 'fault', 'critical'];
            const warningPatterns = ['warning', 'warn', 'alert'];

            const lowerType = eventType.toLowerCase();

            if (errorPatterns.some(p => lowerType.includes(p))) {
                return 'error';
            } else if (warningPatterns.some(p => lowerType.includes(p))) {
                return 'warning';
            }
            return 'info';
        }

        function formatEventBody(body) {
            if (!body || Object.keys(body).length === 0) {
                return 'Keine Details verf√ºgbar';
            }
            return JSON.stringify(body, null, 2);
        }

        // ========================================
        // FILTER FUNCTIONS
        // ========================================

        /**
         * Apply all client-side filters to events
         * Returns filtered events based on globalFilters state
         */
        function applyFilters(events) {
            let filtered = [...events];

            // Time range filter (apply the days filter client-side as well)
            if (globalFilters.days < 365) {
                const cutoffTime = new Date(Date.now() - globalFilters.days * 24 * 60 * 60 * 1000);
                filtered = filtered.filter(event => {
                    const eventTime = new Date(event.eventTimestamp || event.createdAt);
                    return eventTime >= cutoffTime;
                });
            }

            // Timeline zoom range filter (from ECharts dataZoom)
            if (globalFilters.timeRange) {
                filtered = filtered.filter(event => {
                    const eventTime = new Date(event.eventTimestamp || event.createdAt).getTime();
                    return eventTime >= globalFilters.timeRange.start && eventTime <= globalFilters.timeRange.end;
                });
            }

            // Device filter
            if (globalFilters.device !== 'all') {
                filtered = filtered.filter(e => {
                    const deviceKey = `${e.installationId}_${e.deviceId}_${e.modelId}`;
                    return deviceKey === globalFilters.device;
                });
            }

            // Type filter
            if (globalFilters.type !== 'all') {
                filtered = filtered.filter(e => {
                    if (globalFilters.type === 'status') return e.codeCategory === 'status';
                    if (globalFilters.type === 'fault') return e.codeCategory === 'fault';
                    if (globalFilters.type === 'active') return e.active === true;
                    return true;
                });
            }

            // Search filter
            if (globalFilters.search) {
                const searchLower = globalFilters.search.toLowerCase();
                filtered = filtered.filter(e =>
                    e.eventType.toLowerCase().includes(searchLower) ||
                    (e.errorCode && e.errorCode.toLowerCase().includes(searchLower)) ||
                    (e.humanReadable && e.humanReadable.toLowerCase().includes(searchLower)) ||
                    JSON.stringify(e.body).toLowerCase().includes(searchLower)
                );
            }

            // Sort by time (newest first)
            filtered.sort((a, b) => {
                const timeA = new Date(a.eventTimestamp || a.createdAt);
                const timeB = new Date(b.eventTimestamp || b.createdAt);
                return timeB - timeA;
            });

            return filtered;
        }

        /**
         * Update filter state from UI and refresh views
         */
        function updateFiltersFromUI() {
            globalFilters.device = document.getElementById('deviceSelect').value;
            globalFilters.type = document.getElementById('typeFilter').value;
            globalFilters.search = document.getElementById('filterInput').value;
            globalFilters.days = parseFloat(document.getElementById('daysSelect').value);

            // Refresh both views with current data
            refreshViews();
        }

        /**
         * Refresh event list and timeline with current filters
         */
        function refreshViews() {
            // Reset pagination when filters change or new data is loaded
            displayedEventCount = eventsPerPage;

            const filteredEvents = applyFilters(allEvents);
            renderEvents(filteredEvents);
            renderTimeline(filteredEvents);
        }

        // ========================================
        // RENDERING FUNCTIONS
        // ========================================

        /**
         * Render filtered events in the event list
         * Events are already filtered by applyFilters()
         */
        function renderEvents(filteredEvents) {
            const container = document.getElementById('eventsList');

            // Update count
            document.getElementById('eventCount').textContent = `${filteredEvents.length} Events`;

            if (filteredEvents.length === 0) {
                container.innerHTML = '<div class="no-events">Keine Events gefunden</div>';
                return;
            }

            // Limit displayed events for performance
            const eventsToDisplay = filteredEvents.slice(0, displayedEventCount);
            const hasMore = filteredEvents.length > displayedEventCount;

            // Render events
            container.innerHTML = eventsToDisplay.map((event, index) => {
                const category = categorizeEvent(event);
                let statusIndicator = '';
                if (event.active !== null && event.errorCode) {
                    statusIndicator = event.active
                        ? '<span style="color: #c53030;">‚óè AKTIV</span>'
                        : '<span style="color: #48bb78;">‚óè BEENDET</span>';
                }

                const deviceInfo = `<span class="device-info">${event.modelId || 'Unknown'} - Device ${event.deviceId || '0'}</span>`;

                // Get account info
                let accountInfo = '';
                if (event.accountName && event.accountName !== event.accountId) {
                    accountInfo = `<span class="device-info" style="background: rgba(139, 92, 246, 0.15); border-color: rgba(139, 92, 246, 0.3);">üë§ ${event.accountName}</span>`;
                }

                // Get installation info
                let installationInfo = '';
                if (event.installationId && installations[event.installationId]) {
                    const inst = installations[event.installationId];
                    installationInfo = `<span class="device-info" style="background: rgba(102, 126, 234, 0.15); border-color: rgba(102, 126, 234, 0.3);">üìç ${inst.location}</span>`;
                }

                // Build event type display
                let eventTypeDisplay = event.errorCode ? `<strong>${event.errorCode}</strong>` : event.eventType;

                // Special handling for feature-changed events
                if (event.eventType === 'feature-changed' && event.featureName) {
                    eventTypeDisplay = `<strong>feature-changed</strong>: ${event.featureName}`;
                    if (event.featureValue) {
                        eventTypeDisplay += ` <span style="color: #a0a0b0; font-size: 12px;">(${event.featureValue})</span>`;
                    }
                }

                return `
                    <div class="event-item" onclick="toggleEvent(${index})">
                        <div class="event-header">
                            <div class="event-time">${formatTimestamp(event.eventTimestamp || event.createdAt)}</div>
                            <div class="event-type">
                                ${eventTypeDisplay}
                                ${deviceInfo}
                                ${accountInfo}
                                ${installationInfo}
                                ${event.humanReadable ? `<div class="code-description">${event.humanReadable}&nbsp &nbsp${statusIndicator}</div>` : `${statusIndicator}`}
                            </div>
                            <div class="event-badge ${category}">${category.toUpperCase()}</div>
                        </div>
                        <div class="event-details" id="details-${index}">
Event Type: ${event.eventType}
${event.featureName ? 'Feature: ' + event.featureName + '\n' : ''}
${event.featureValue ? 'Wert: ' + event.featureValue + '\n' : ''}
${event.errorCode ? 'Error Code: ' + event.errorCode + '\n' : ''}
${event.humanReadable ? 'Bedeutung: ' + event.humanReadable + '\n' : ''}
${event.errorDescription ? 'System-Beschreibung: ' + event.errorDescription + '\n' : ''}
Ger√§t: ${event.modelId || 'Unknown'} (ID: ${event.deviceId || '0'})
Gateway Serial: ${event.gatewaySerial || 'N/A'}

Rohdaten:
${formatEventBody(event.body)}
                        </div>
                    </div>
                `;
            }).join('');

            // Add "Load More" button if there are more events
            if (hasMore) {
                const remaining = filteredEvents.length - displayedEventCount;
                container.innerHTML += `
                    <div style="text-align: center; padding: 20px;">
                        <button onclick="loadMoreEvents()" style="
                            padding: 12px 24px;
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            border: none;
                            border-radius: 8px;
                            font-size: 14px;
                            cursor: pointer;
                            transition: all 0.2s;
                        ">
                            Mehr laden (${remaining} weitere Events)
                        </button>
                    </div>
                `;
            }
        }

        function loadMoreEvents() {
            displayedEventCount += eventsPerPage;
            // Re-render with increased count
            const filteredEvents = applyFilters(allEvents);
            renderEvents(filteredEvents);
        }

        function toggleEvent(index) {
            const item = document.querySelectorAll('.event-item')[index];
            item.classList.toggle('expanded');
        }

        // ========================================
        // DATA LOADING
        // ========================================

        /**
         * Load events from server based on globalFilters.days
         * Then apply client-side filters and render
         */
        async function loadEvents() {
            const btn = document.getElementById('refreshBtn');
            btn.disabled = true;
            btn.textContent = 'Lade...';

            // Update filter state from UI before loading
            updateFiltersFromUI();

            try {
                const response = await fetch(`/api/events?days=${globalFilters.days}`);
                if (!response.ok) throw new Error('Fehler beim Laden der Events');

                allEvents = await response.json();

                // Load device list first to populate installations
                await updateDeviceList();

                // Apply filters and render both views
                refreshViews();

                // Update last fetch time
                const now = new Date();
                document.getElementById('lastFetch').textContent =
                    `Letzte Aktualisierung: ${now.toLocaleTimeString()}`;

            } catch (error) {
                console.error('Error:', error);
                document.getElementById('eventsList').innerHTML =
                    `<div class="error-message">Fehler beim Laden der Events: ${error.message}</div>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Aktualisieren';
            }
        }

        /**
         * Update device dropdown and installations cache
         * Preserves current selection from globalFilters
         */
        async function updateDeviceList() {
            const deviceSelect = document.getElementById('deviceSelect');

            try {
                // Fetch devices grouped by installation from API
                const response = await fetch('/api/devices');
                const devicesByInstallation = await response.json();

                // Store installation data for timeline use
                installations = {};
                devicesByInstallation.forEach(installation => {
                    installations[installation.installationId] = {
                        description: installation.description,
                        location: installation.location
                    };
                });

                // Update select options
                deviceSelect.innerHTML = '<option value="all">Alle Ger√§te</option>';

                // Add grouped options by installation
                devicesByInstallation.forEach(installation => {
                    // Create optgroup for installation
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = `üìç ${installation.description || installation.installationId} - ${installation.location}`;

                    installation.devices.forEach(device => {
                        const option = document.createElement('option');
                        const key = `${installation.installationId}_${device.deviceId}_${device.modelId}`;
                        option.value = key;
                        option.textContent = `${device.modelId} (Device ${device.deviceId})`;
                        optgroup.appendChild(option);
                    });

                    deviceSelect.appendChild(optgroup);
                });

                // Restore selection from globalFilters
                const allOptions = deviceSelect.querySelectorAll('option');
                const optionExists = Array.from(allOptions).some(opt => opt.value === globalFilters.device);
                if (optionExists) {
                    deviceSelect.value = globalFilters.device;
                } else {
                    // If previous selection doesn't exist anymore, reset to 'all'
                    globalFilters.device = 'all';
                    deviceSelect.value = 'all';
                }
            } catch (error) {
                console.error('Error loading devices:', error);
            }
        }

        async function loadStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();

                const dot = document.getElementById('statusDot');
                const text = document.getElementById('statusText');
                const info = document.getElementById('deviceInfo');

                if (status.connected) {
                    dot.classList.add('connected');
                    text.textContent = 'Verbunden';
                    info.textContent = `Device: ${status.device_id || 'Unknown'}`;
                } else {
                    dot.classList.remove('connected');
                    text.textContent = 'Nicht verbunden';
                    info.textContent = '';
                }
            } catch (error) {
                console.error('Status error:', error);
            }
        }

        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            autoRefreshEnabled = !autoRefreshEnabled;

            if (autoRefreshEnabled) {
                btn.textContent = 'Auto-Refresh: An';
                btn.style.background = '#10b981';
                autoRefreshInterval = setInterval(loadEvents, 60000); // Every minute
            } else {
                btn.textContent = 'Auto-Refresh: Aus';
                btn.style.background = '#667eea';
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                }
            }
        }

        // ========================================
        // EVENT LISTENERS
        // ========================================

        // Filter input - update search filter and refresh views
        document.getElementById('filterInput').addEventListener('input', () => {
            globalFilters.search = document.getElementById('filterInput').value;
            refreshViews();
        });

        // Device filter - update and refresh views
        document.getElementById('deviceSelect').addEventListener('change', () => {
            globalFilters.device = document.getElementById('deviceSelect').value;
            refreshViews();
        });

        // Type filter - update and refresh views
        document.getElementById('typeFilter').addEventListener('change', () => {
            globalFilters.type = document.getElementById('typeFilter').value;
            refreshViews();
        });

        // Days filter - reload from server
        document.getElementById('daysSelect').addEventListener('change', () => {
            globalFilters.days = parseFloat(document.getElementById('daysSelect').value);
            loadEvents();
        });

        // ========================================
        // TIMELINE RENDERING
        // ========================================

        /**
         * Render timeline with already filtered events using ECharts
         * Events are pre-filtered by applyFilters() (including time range)
         * Timeline only applies event type filter (globalFilters.timelineTypes)
         */
        function renderTimeline(events) {
            renderTimelineECharts(events);
        }

        // ========================================
        // ECHARTS TIMELINE RENDERING
        // ========================================
        let timelineChart = null;
        const DateTime = luxon.DateTime;

        /**
         * Render timeline using ECharts (replaces SVG rendering)
         */
        function renderTimelineECharts(events) {
            const container = document.getElementById('timeline');
            const controlsContainer = document.getElementById('timelineControls');

            if (!events || events.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">Keine Events verf√ºgbar</div>';
                return;
            }

            // Event type definitions (same as original)
            const eventTypes = {
                'S.125': { label: 'Heizen', description: 'W√§rmepumpe im Heizbetrieb', color: '#ef4444', gradient: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)', icon: 'üî•' },
                'S.125-WARMWATER': { label: 'WW-Bereitung', description: 'Warmwasserbereitung aktiv', color: '#8b5cf6', gradient: 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)', icon: 'üöø' },
                'S.126': { label: 'K√ºhlen', description: 'W√§rmepumpe im K√ºhlbetrieb', color: '#06b6d4', gradient: 'linear-gradient(135deg, #06b6d4 0%, #0891b2 100%)', icon: '‚ùÑÔ∏è' },
                'S.127': { label: 'Abtau-Vorb.', description: 'W√§rmepumpe: Abtauen vorbereiten', color: '#06d6a0', gradient: 'linear-gradient(135deg, #06d6a0 0%, #00b894 100%)', icon: 'üßä' },
                'S.128': { label: 'Abtauen', description: 'W√§rmepumpe im Abtaubetrieb', color: '#14b8a6', gradient: 'linear-gradient(135deg, #14b8a6 0%, #0d9488 100%)', icon: 'üíß' },
                'S.123': { label: 'Aus', description: 'W√§rmepumpe ausgeschaltet', color: '#64748b', gradient: 'linear-gradient(135deg, #64748b 0%, #475569 100%)', icon: '‚è∏' },
                'S.124': { label: 'Vorlauf', description: 'W√§rmepumpe Vorlaufphase', color: '#f59e0b', gradient: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', icon: '‚è´' },
                'S.129': { label: 'Nachlauf', description: 'W√§rmepumpe Nachlaufphase', color: '#3b82f6', gradient: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)', icon: '‚è¨' },
                'S.112': { label: 'V-Init', description: 'Ventil initialisiert', color: '#94a3b8', gradient: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', icon: 'üîß' },
                'S.113': { label: 'V‚ÜíWW', description: 'Ventil schaltet zu Warmwasser', color: '#c084fc', gradient: 'linear-gradient(135deg, #c084fc 0%, #a855f7 100%)', icon: '‚Üí' },
                'S.114': { label: 'V‚ÜíHK1', description: 'Ventil schaltet zu Heizkreis 1', color: '#fb923c', gradient: 'linear-gradient(135deg, #fb923c 0%, #f97316 100%)', icon: '‚Üí' },
                'S.115': { label: 'V-WW', description: 'Ventil in Warmwasser-Position', color: '#a78bfa', gradient: 'linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%)', icon: 'üîÄ' },
                'S.116': { label: 'V-HK1', description: 'Ventil in Heizkreis 1 Position', color: '#f97316', gradient: 'linear-gradient(135deg, #f97316 0%, #ea580c 100%)', icon: 'üîÄ' },
                'S.117': { label: 'V-HK2', description: 'Ventil in Heizkreis 2 Position', color: '#f59e0b', gradient: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', icon: 'üîÄ' },
                'S.118': { label: 'V-Puffer', description: 'Ventil in Pufferspeicher-Position', color: '#10b981', gradient: 'linear-gradient(135deg, #10b981 0%, #059669 100%)', icon: 'üîÑ' },
                'S.134': { label: 'V-Leerlauf', description: 'Ventil im Leerlauf', color: '#6b7280', gradient: 'linear-gradient(135deg, #6b7280 0%, #4b5563 100%)', icon: '‚≠ï' },
                'S.135': { label: 'V-Abtauen', description: 'Ventil in Abtau-Position', color: '#22d3ee', gradient: 'linear-gradient(135deg, #22d3ee 0%, #06b6d4 100%)', icon: 'üîÄ' },
                'S.136': { label: 'V-Raumheizung', description: 'Ventil in Raumheizungs-Position', color: '#84cc16', gradient: 'linear-gradient(135deg, #84cc16 0%, #65a30d 100%)', icon: 'üè†' },
                'S.168': { label: 'Bypass offen', description: 'L√ºftungsbypass ge√∂ffnet', color: '#22c55e', gradient: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', icon: 'üå¨Ô∏è' },
                'S.169': { label: 'Bypass zu', description: 'L√ºftungsbypass geschlossen', color: '#6b7280', gradient: 'linear-gradient(135deg, #6b7280 0%, #4b5563 100%)', icon: 'üö´' },
                'I.120': { label: 'Silentmode', description: 'Ger√§uschreduzierter Betrieb W√§rmepumpe aktiv', color: '#6366f1', gradient: 'linear-gradient(135deg, #6366f1 0%, #4f46e5 100%)', icon: 'üîá' },
                'I.121': { label: 'Feuchte HK1', description: 'Feuchteanbauschalter Heizkreis 1 aktiv', color: '#fbbf24', gradient: 'linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%)', icon: 'üí¶' },
                'I.122': { label: 'Feuchte HK2', description: 'Feuchteanbauschalter Heizkreis 2 aktiv', color: '#fb923c', gradient: 'linear-gradient(135deg, #fb923c 0%, #f97316 100%)', icon: 'üí¶' },
                'I.135': { label: 'Abtauen', description: 'Abtauen aktiv im Regelbetrieb', color: '#0ea5e9', gradient: 'linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%)', icon: '‚ùÑÔ∏è' },
                'S.176': { label: 'Abtauen Anfr.', description: 'W√§rmepumpenregelung: Abtauen angefordert', color: '#06b6d4', gradient: 'linear-gradient(135deg, #06b6d4 0%, #0891b2 100%)', icon: '‚ùÑÔ∏è' },
                'S.187': { label: 'Frostschutz', description: 'Passiver Frostschutz W√§rmepumpe eingeschaltet', color: '#3b82f6', gradient: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)', icon: 'üßä' },
                'S.427': { label: '¬ß14a EnWG', description: 'Leistungsbegrenzung durch Netzbetreiber nach ¬ß14a EnWG', color: '#f59e0b', gradient: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', icon: '‚ö°' },
                'S.432': { label: 'Abtauen L√ºfter', description: 'Abtauung des L√ºfters aktiv', color: '#f59e0b', gradient: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', icon: 'üíß' },
                'S.131': { label: 'Zusatz Stufe 1', description: 'Heizwasser-Durchlauferhitzer: Stufe 1 aktiv', color: '#fb923c', gradient: 'linear-gradient(135deg, #fb923c 0%, #f97316 100%)', icon: 'üî•' },
                'S.132': { label: 'Zusatz Stufe 2', description: 'Heizwasser-Durchlauferhitzer: Stufe 2 aktiv', color: '#f97316', gradient: 'linear-gradient(135deg, #f97316 0%, #ea580c 100%)', icon: 'üî•' },
                'S.133': { label: 'Zusatz Stufe 3', description: 'Heizwasser-Durchlauferhitzer: Stufe 3 aktiv', color: '#ea580c', gradient: 'linear-gradient(135deg, #ea580c 0%, #dc2626 100%)', icon: 'üî•' }
            };

            // Setup filter buttons (same as original)
            controlsContainer.innerHTML = Object.entries(eventTypes).map(([code, info]) => {
                const active = globalFilters.timelineTypes[code] !== false;
                return `
                    <button onclick="toggleTimelineFilter('${code}')"
                            title="${info.description}"
                            style="padding: 7px 13px; border: 1px solid ${active ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.15)'};
                                   background: ${active ? info.gradient : 'rgba(255,255,255,0.05)'};
                                   color: ${active ? 'white' : '#a0a0b0'};
                                   border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500;
                                   transition: all 0.2s; display: inline-flex; align-items: center; gap: 6px;
                                   ${active ? 'box-shadow: 0 2px 8px ' + info.color + '40;' : ''}">
                        <span style="font-size: 14px;">${info.icon}</span>
                        ${info.label}
                    </button>
                `;
            }).join('');

            // Process events with state machine (from grafana prototype)
            const { data, categories } = processEventsForECharts(events, eventTypes);

            if (!data || data.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">Keine Events im ausgew√§hlten Zeitraum gefunden</div>';
                return;
            }

            // Initialize or get chart
            if (!timelineChart) {
                timelineChart = echarts.init(container, 'dark');
            }

            // Calculate dynamic height
            const rowHeight = 50;
            const chartHeight = Math.max(400, categories.length * rowHeight + 150);
            container.style.height = chartHeight + 'px';
            timelineChart.resize();

            // ECharts configuration
            const option = {
                backgroundColor: 'transparent',
                tooltip: {
                    trigger: 'item',
                    formatter: function (params) {
                        try {
                            const { name, value, data } = params;
                            if (!value || !Array.isArray(value) || value.length < 4) {
                                return `<div style="padding: 8px;">${name}</div>`;
                            }
                            const startTime = value[1];
                            const endTime = value[2];
                            const duration = value[3];
                            if (!startTime || !endTime || isNaN(startTime) || isNaN(endTime)) {
                                return `<div style="padding: 8px;">${name}</div>`;
                            }

                            // Point events (gateway events, etc.) show only timestamp
                            if (data?.isPointEvent) {
                                const timestamp = DateTime.fromMillis(startTime).toFormat('dd.MM.yyyy HH:mm:ss');
                                return `
                                    <div style="padding: 8px;">
                                        <div style="font-weight: bold; margin-bottom: 4px;">
                                            ${data?.icon || 'üìå'} ${name}
                                        </div>
                                        <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">
                                            ${data?.description || ''}
                                        </div>
                                        <div style="font-size: 12px;">
                                            <strong>Zeitpunkt:</strong> ${timestamp}
                                        </div>
                                    </div>
                                `;
                            }

                            // Regular events show start, end, and duration
                            const start = DateTime.fromMillis(startTime).toFormat('dd.MM.yyyy HH:mm:ss');
                            const end = DateTime.fromMillis(endTime).toFormat('dd.MM.yyyy HH:mm:ss');
                            const durationStr = formatDurationECharts(duration);
                            return `
                                <div style="padding: 8px;">
                                    <div style="font-weight: bold; margin-bottom: 4px;">
                                        ${data?.icon || '‚Ä¢'} ${name}
                                    </div>
                                    <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">
                                        ${data?.description || ''}
                                    </div>
                                    <div style="font-size: 12px;">
                                        <strong>Start:</strong> ${start}<br>
                                        <strong>Ende:</strong> ${end}<br>
                                        <strong>Dauer:</strong> ${durationStr}
                                    </div>
                                </div>
                            `;
                        } catch (error) {
                            return `<div style="padding: 8px;">${params.name || 'Event'}</div>`;
                        }
                    }
                },
                toolbox: {
                    feature: {
                        dataZoom: {
                            yAxisIndex: 'none',
                            title: { zoom: 'Bereich zoomen', back: 'Zur√ºck' }
                        },
                        restore: { title: 'Zur√ºcksetzen' },
                        saveAsImage: { title: 'Als Bild speichern', name: 'vieventlog-timeline' }
                    },
                    iconStyle: { borderColor: '#e0e0e0' },
                    emphasis: { iconStyle: { borderColor: '#667eea' } }
                },
                dataZoom: [
                    {
                        type: 'slider',
                        filterMode: 'weakFilter',
                        xAxisIndex: [0],
                        bottom: 10,
                        height: 30,
                        borderColor: 'rgba(255,255,255,0.2)',
                        backgroundColor: 'rgba(0,0,0,0.3)',
                        fillerColor: 'rgba(102, 126, 234, 0.2)',
                        handleStyle: { color: '#667eea' },
                        textStyle: { color: '#e0e0e0' },
                        labelFormatter: function(value) {
                            try {
                                return DateTime.fromMillis(value).toFormat('dd.MM HH:mm');
                            } catch (e) {
                                return '';
                            }
                        }
                    },
                    {
                        type: 'inside',
                        xAxisIndex: [0],
                        zoomOnMouseWheel: true,
                        moveOnMouseMove: true
                    }
                ],
                grid: {
                    left: window.innerWidth <= 768 ? 80 : 250,
                    right: window.innerWidth <= 768 ? 20 : 50,
                    top: 60,
                    bottom: 80
                },
                xAxis: {
                    type: 'time',
                    axisLabel: {
                        formatter: function(value) {
                            return DateTime.fromMillis(value).toFormat('dd.MM\nHH:mm');
                        },
                        color: '#a0a0b0'
                    },
                    axisLine: { lineStyle: { color: 'rgba(255,255,255,0.2)' } },
                    splitLine: { show: true, lineStyle: { color: 'rgba(255,255,255,0.1)', type: 'dashed' } }
                },
                yAxis: {
                    type: 'category',
                    data: categories,
                    inverse: true, // First category at top
                    axisLabel: {
                        color: '#e0e0e0',
                        fontSize: window.innerWidth <= 768 ? 9 : 11,
                        lineHeight: 16,
                        width: window.innerWidth <= 768 ? 60 : 220,
                        overflow: 'truncate',
                        formatter: function(value) {
                            // Apply rich text styling for installation headers
                            if (value && value.startsWith('üìç')) {
                                // Truncate long installation names on mobile
                                if (window.innerWidth <= 768) {
                                    const maxLen = 12;
                                    const truncated = value.length > maxLen ? value.substring(0, maxLen) + '...' : value;
                                    return `{header|${truncated}}`;
                                }
                                return `{header|${value}}`;
                            }
                            // Truncate device names on mobile
                            if (window.innerWidth <= 768 && value.length > 10) {
                                return value.substring(0, 10) + '...';
                            }
                            return value;
                        },
                        rich: {
                            header: {
                                color: '#ffffff',
                                fontWeight: 'bold',
                                fontSize: window.innerWidth <= 768 ? 9 : 11,
                                lineHeight: 16,
                                backgroundColor: 'rgba(102, 126, 234, 0.3)',
                                borderRadius: 4,
                                padding: [6, 8, 6, 6]
                            }
                        }
                    },
                    axisLine: { lineStyle: { color: 'rgba(255,255,255,0.2)' } },
                    splitLine: {
                        show: true,
                        lineStyle: {
                            color: 'rgba(102, 126, 234, 0.15)',
                            width: 1,
                            type: 'solid'
                        }
                    }
                },
                series: [{
                    type: 'custom',
                    renderItem: renderGanttItemECharts,
                    encode: { x: [1, 2], y: 0 },
                    data: data
                }]
            };

            timelineChart.setOption(option);

            // Listen to dataZoom events to filter event list
            timelineChart.off('datazoom');
            timelineChart.on('datazoom', function(params) {
                const option = timelineChart.getOption();
                const dataZoom = option.dataZoom[0];

                if (dataZoom && dataZoom.startValue !== undefined && dataZoom.endValue !== undefined) {
                    // Set the time range filter
                    globalFilters.timeRange = {
                        start: dataZoom.startValue,
                        end: dataZoom.endValue
                    };

                    // Update the reset button visibility
                    const resetBtn = document.getElementById('resetZoomBtn');
                    if (resetBtn) {
                        resetBtn.style.display = 'inline-flex';
                    }

                    // Re-render events with the new time range filter
                    const filteredEvents = applyFilters(allEvents);
                    renderEvents(filteredEvents);
                }
            });

            // Handle window resize
            window.removeEventListener('resize', handleTimelineResize);
            window.addEventListener('resize', handleTimelineResize);
        }

        function handleTimelineResize() {
            if (timelineChart) {
                // Update grid settings based on new window width
                const isMobile = window.innerWidth <= 768;
                const option = timelineChart.getOption();

                if (option.grid && option.grid[0]) {
                    option.grid[0].left = isMobile ? 80 : 250;
                    option.grid[0].right = isMobile ? 20 : 50;
                }

                if (option.yAxis && option.yAxis[0] && option.yAxis[0].axisLabel) {
                    option.yAxis[0].axisLabel.fontSize = isMobile ? 9 : 11;
                    option.yAxis[0].axisLabel.width = isMobile ? 60 : 220;
                }

                timelineChart.setOption(option);
                timelineChart.resize();
            }
        }

        /**
         * Reset timeline zoom and show all events
         */
        function resetTimelineZoom() {
            if (timelineChart) {
                // Reset the dataZoom to show all data
                timelineChart.dispatchAction({
                    type: 'dataZoom',
                    start: 0,
                    end: 100
                });
            }

            // Clear the time range filter
            globalFilters.timeRange = null;

            // Hide the reset button
            const resetBtn = document.getElementById('resetZoomBtn');
            if (resetBtn) {
                resetBtn.style.display = 'none';
            }

            // Re-render events without time range filter
            const filteredEvents = applyFilters(allEvents);
            renderEvents(filteredEvents);
        }

        function formatDurationECharts(minutes) {
            if (minutes < 1) {
                return `${Math.round(minutes * 60)}s`;
            } else if (minutes < 60) {
                return `${Math.round(minutes)}min`;
            } else if (minutes < 1440) {
                let hours = Math.floor(minutes / 60);
                let mins = Math.round(minutes % 60);
                // Handle minute overflow (e.g., 59.5 rounds to 60)
                if (mins === 60) {
                    hours += 1;
                    mins = 0;
                }
                return mins === 0 ? `${hours}h` : `${hours}h ${mins}min`;
            } else {
                const days = Math.floor(minutes / 1440);
                const remainingMinutes = minutes % 1440;
                let hours = Math.floor(remainingMinutes / 60);
                let mins = Math.round(remainingMinutes % 60);
                // Handle minute overflow
                if (mins === 60) {
                    hours += 1;
                    mins = 0;
                }
                return hours === 0 ? `${days}d` : `${days}d ${hours}h`;
            }
        }

        function renderGanttItemECharts(params, api) {
            const categoryIndex = api.value(0);
            const start = api.coord([api.value(1), categoryIndex]);
            const end = api.coord([api.value(2), categoryIndex]);
            const height = api.size([0, 1])[1] * 0.6;
            const duration = api.value(3); // Duration in minutes

            const rectShape = echarts.graphic.clipRectByRect(
                {
                    x: start[0],
                    y: start[1] - height / 2,
                    width: end[0] - start[0],
                    height: height
                },
                {
                    x: params.coordSys.x,
                    y: params.coordSys.y,
                    width: params.coordSys.width,
                    height: params.coordSys.height
                }
            );

            if (!rectShape) return null;

            const barWidth = end[0] - start[0];
            const minWidthForText = 40; // Minimum pixel width to show duration text

            // Create base rect
            const elements = [{
                type: 'rect',
                transition: ['shape'],
                shape: rectShape,
                style: api.style(),
                z: (params.data && params.data.z) || 1
            }];

            // Add duration text if bar is wide enough and text position is within visible area
            if (barWidth >= minWidthForText && duration !== undefined) {
                const textX = start[0] + barWidth / 2;
                const textMargin = 30; // Approximate half-width of text for better boundary check

                // Only show text if it's within the visible coordinate system boundaries
                const isTextVisible = (textX - textMargin) >= params.coordSys.x &&
                                     (textX + textMargin) <= (params.coordSys.x + params.coordSys.width);

                if (isTextVisible) {
                    const durationStr = formatDurationECharts(duration);
                    elements.push({
                        type: 'text',
                        style: {
                            text: durationStr,
                            x: textX,
                            y: start[1],
                            fill: 'white',
                            fontSize: 11,
                            fontWeight: 'bold',
                            textAlign: 'center',
                            textVerticalAlign: 'middle',
                            textShadowColor: 'rgba(0,0,0,0.8)',
                            textShadowBlur: 3,
                            textShadowOffsetX: 1,
                            textShadowOffsetY: 1
                        },
                        z: ((params.data && params.data.z) || 1) + 1
                    });
                }
            }

            return {
                type: 'group',
                children: elements
            };
        }

        function processEventsForECharts(events, eventTypes) {
            // Group events by device
            const lanes = {};
            events.forEach(event => {
                const laneKey = `${event.installationId}_${event.modelId}_${event.deviceId}`;
                if (!lanes[laneKey]) {
                    // Create a friendly name for the device
                    let deviceName;
                    if (event.modelId === 'Unknown' && event.deviceId === '0') {
                        // Gateway-level events (gateway-online, gateway-offline, etc.)
                        deviceName = 'Gateway';
                    } else if (event.modelId === 'Unknown') {
                        deviceName = `Unknown (${event.deviceId})`;
                    } else {
                        deviceName = `${event.modelId} (${event.deviceId})`;
                    }

                    lanes[laneKey] = {
                        name: deviceName,
                        installationId: event.installationId || 'Unknown',
                        events: [],
                        hasValveSpans: false,
                        pointEvents: []  // For events without active field
                    };
                }
                lanes[laneKey].events.push(event);
            });

            // Helper functions
            const isValveCode = (c) => {
                return c && ((c >= 'S.112' && c <= 'S.118') || (c >= 'S.134' && c <= 'S.136'));
            };

            const valvePositionMap = {
                'S.112': 'init', 'S.113': 'switching-ww', 'S.114': 'switching-hk1',
                'S.115': 'warmwater', 'S.116': 'heating-hk1', 'S.117': 'heating-hk2',
                'S.118': 'buffer', 'S.134': 'idle', 'S.135': 'defrost', 'S.136': 'room'
            };

            // Process each lane to create state spans
            Object.values(lanes).forEach(lane => {
                lane.spans = [];
                lane.valveSpans = [];
                const activeStates = {};
                const activeValveStates = {};
                let currentValvePosition = null;

                // Sort events by time
                const sortedEvents = lane.events.sort((a, b) => {
                    const aTime = new Date(a.eventTimestamp || a.createdAt);
                    const bTime = new Date(b.eventTimestamp || b.createdAt);
                    return aTime - bTime;
                });

                sortedEvents.forEach(event => {
                    const code = event.errorCode;
                    const eventTime = event.eventTimestamp || event.createdAt;
                    const eventType = event.eventType;

                    // Handle events without errorCode (e.g., gateway-online/offline, feature-changed)
                    // These are point events that should be shown as markers
                    if (!code && eventType && event.active === null) {
                        lane.pointEvents.push({
                            eventType: eventType,
                            timestamp: eventTime,
                            event: event
                        });
                        return; // Skip further processing for point events
                    }

                    if (!code) return;

                    // Handle valve position codes separately
                    if (isValveCode(code)) {
                        lane.hasValveSpans = true;
                        if (event.active === true) {
                            activeValveStates[code] = { startTime: eventTime, startEvent: event };
                        } else if (event.active === false && activeValveStates[code]) {
                            lane.valveSpans.push({
                                code: code,
                                startTime: activeValveStates[code].startTime,
                                endTime: eventTime,
                                startEvent: activeValveStates[code].startEvent,
                                endEvent: event
                            });
                            delete activeValveStates[code];
                        }
                    }

                    // Handle valve position transitions for S.125-WARMWATER overlay
                    if (valvePositionMap[code]) {
                        if (event.active === true) {
                            const newValvePosition = valvePositionMap[code];
                            if (code === 'S.115' && activeStates['S.125']) {
                                activeStates['S.125-WARMWATER'] = {
                                    startTime: eventTime,
                                    startEvent: event,
                                    originalCode: 'S.125',
                                    valvePosition: 'warmwater',
                                    parentS125: activeStates['S.125']
                                };
                            }
                            if (activeStates['S.125-WARMWATER'] && (code === 'S.116' || code === 'S.117' || code === 'S.118' || code === 'S.134' || code === 'S.135' || code === 'S.136')) {
                                lane.spans.push({
                                    code: 'S.125-WARMWATER',
                                    originalCode: 'S.125',
                                    startTime: activeStates['S.125-WARMWATER'].startTime,
                                    endTime: eventTime,
                                    startEvent: activeStates['S.125-WARMWATER'].startEvent,
                                    endEvent: event,
                                    valvePosition: 'warmwater'
                                });
                                delete activeStates['S.125-WARMWATER'];
                            }
                            currentValvePosition = newValvePosition;
                        } else if (event.active === false) {
                            if (code === 'S.115' && activeStates['S.125-WARMWATER']) {
                                lane.spans.push({
                                    code: 'S.125-WARMWATER',
                                    originalCode: 'S.125',
                                    startTime: activeStates['S.125-WARMWATER'].startTime,
                                    endTime: eventTime,
                                    startEvent: activeStates['S.125-WARMWATER'].startEvent,
                                    endEvent: event,
                                    valvePosition: 'warmwater'
                                });
                                delete activeStates['S.125-WARMWATER'];
                                currentValvePosition = null;
                            }
                        }
                    }

                    // Process main state events (non-valve codes)
                    if (!isValveCode(code)) {
                        if (event.active === true) {
                            activeStates[code] = {
                                startTime: eventTime,
                                startEvent: event,
                                originalCode: code,
                                valvePosition: currentValvePosition
                            };
                        } else if (event.active === false && activeStates[code]) {
                            lane.spans.push({
                                code: code,
                                originalCode: code,
                                startTime: activeStates[code].startTime,
                                endTime: eventTime,
                                startEvent: activeStates[code].startEvent,
                                endEvent: event,
                                valvePosition: activeStates[code].valvePosition
                            });
                            delete activeStates[code];
                        }
                    }
                });

                // Add ongoing states
                Object.entries(activeStates).forEach(([code, state]) => {
                    lane.spans.push({
                        code: code,
                        originalCode: state.originalCode,
                        startTime: state.startTime,
                        endTime: new Date().toISOString(),
                        startEvent: state.startEvent,
                        endEvent: null,
                        ongoing: true,
                        valvePosition: state.valvePosition
                    });
                });

                Object.entries(activeValveStates).forEach(([code, state]) => {
                    lane.valveSpans.push({
                        code: code,
                        startTime: state.startTime,
                        endTime: new Date().toISOString(),
                        startEvent: state.startEvent,
                        endEvent: null,
                        ongoing: true
                    });
                });
            });

            // Group lanes by installation
            const lanesByInstallation = {};
            Object.entries(lanes).forEach(([laneKey, lane]) => {
                const instId = lane.installationId;
                if (!lanesByInstallation[instId]) {
                    lanesByInstallation[instId] = [];
                }
                lanesByInstallation[instId].push({ laneKey, lane });
            });

            // Helper function to wrap text at specified length
            const wrapText = (text, maxLength = 25) => {
                if (text.length <= maxLength) return text;
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';

                words.forEach(word => {
                    if ((currentLine + ' ' + word).length <= maxLength) {
                        currentLine += (currentLine ? ' ' : '') + word;
                    } else {
                        if (currentLine) lines.push(currentLine);
                        currentLine = word;
                    }
                });
                if (currentLine) lines.push(currentLine);
                return lines.join('\n');
            };

            // Convert to ECharts format with installation grouping
            const timelineData = [];
            const categories = [];
            let categoryIndex = 0;

            Object.entries(lanesByInstallation).forEach(([instId, lanesInInst]) => {
                // Add installation header (Adresse + Ort)
                const installation = installations[instId];
                let instHeader = 'üìç Installation ' + instId;
                if (installation) {
                    if (installation.description && installation.location) {
                        instHeader = `üìç ${installation.description} - ${installation.location}`;
                    } else if (installation.description) {
                        instHeader = `üìç ${installation.description}`;
                    } else if (installation.location) {
                        instHeader = `üìç ${installation.location}`;
                    }
                }

                // Wrap long installation names
                instHeader = wrapText(instHeader, 25);

                categories.push(instHeader);
                categoryIndex++; // Skip the header row (no data on this row)

                // Add each device in this installation
                lanesInInst.forEach(({ laneKey, lane }) => {
                    // Add valve position FIRST (above the main device)
                    let valveCategoryIndex = null;
                    if (lane.hasValveSpans) {
                        categories.push(`Ventilposition`);
                        valveCategoryIndex = categoryIndex;
                        categoryIndex++;
                    }

                    // Device name only (location is already in the installation header)
                    categories.push(lane.name);
                    const mainCategoryIndex = categoryIndex;
                    categoryIndex++;

                    // Add main spans
                    lane.spans.forEach(span => {
                        // Skip blacklisted events
                        if (globalFilters.timelineBlacklist && globalFilters.timelineBlacklist.includes(span.code)) return;
                        // Skip filtered events
                        if (globalFilters.timelineTypes[span.code] === false) return;
                        const startTime = new Date(span.startTime);
                        const endTime = new Date(span.endTime);
                        const duration = (endTime - startTime) / 1000 / 60;

                        timelineData.push({
                            name: eventTypes[span.code]?.label || span.code,
                            value: [mainCategoryIndex, startTime.getTime(), endTime.getTime(), duration],
                            itemStyle: {
                                normal: {
                                    color: eventTypes[span.code]?.color || '#64748b',
                                    opacity: span.code === 'S.125-WARMWATER' ? 0.95 : 1
                                }
                            },
                            code: span.code,
                            description: eventTypes[span.code]?.description || span.code,
                            icon: eventTypes[span.code]?.icon || '‚Ä¢',
                            ongoing: span.ongoing,
                            // S.125-WARMWATER should be rendered on top
                            z: span.code === 'S.125-WARMWATER' ? 10 : 1
                        });
                    });

                    // Add valve spans
                    if (valveCategoryIndex !== null) {
                        lane.valveSpans.forEach(span => {
                            // Skip blacklisted events
                            if (globalFilters.timelineBlacklist && globalFilters.timelineBlacklist.includes(span.code)) return;
                            // Skip filtered events
                            if (globalFilters.timelineTypes[span.code] === false) return;
                            const startTime = new Date(span.startTime);
                            const endTime = new Date(span.endTime);
                            const duration = (endTime - startTime) / 1000 / 60;

                            timelineData.push({
                                name: eventTypes[span.code]?.label || span.code,
                                value: [valveCategoryIndex, startTime.getTime(), endTime.getTime(), duration],
                                itemStyle: { normal: { color: eventTypes[span.code]?.color || '#64748b' } },
                                code: span.code,
                                description: eventTypes[span.code]?.description || span.code,
                                icon: eventTypes[span.code]?.icon || '‚Ä¢',
                                ongoing: span.ongoing
                            });
                        });
                    }

                    // Add point events (events without active field, shown as markers)
                    if (lane.pointEvents && lane.pointEvents.length > 0) {
                        lane.pointEvents.forEach(pointEvent => {
                            const eventType = pointEvent.eventType;

                            // Build display name with feature name and value for feature-changed events
                            let eventDisplayName = pointEvent.event.featureName;
                            const featureValueLen = 35;

                            if (eventDisplayName === undefined) {
                                eventDisplayName = eventType;
                            } else {
                                const featureValue = pointEvent.event.featureValue;
                                if (featureValue !== undefined && featureValue.length > 0) {
                                    if (featureValue.length < featureValueLen) {
                                        eventDisplayName = eventDisplayName + "<br>" + featureValue;
                                    } else {
                                        const cleanValue = featureValue.replaceAll("]", " ");
                                        eventDisplayName = eventDisplayName + "<br>" + cleanValue.slice(cleanValue.length - featureValueLen);
                                    }
                                }
                            }

                            // Skip if this event type is filtered out
                            // Point events use eventType as their identifier
                            if (globalFilters.timelineTypes[eventType] === false) return;

                            const timestamp = new Date(pointEvent.timestamp);
                            // Show point events as 5-minute markers for visibility
                            const pointDuration = 5; // minutes
                            const endTime = new Date(timestamp.getTime() + pointDuration * 60 * 1000);

                            // Define colors and labels for point events
                            const pointEventConfig = {
                                'gateway-online': { color: '#10b981', label: 'Gateway Online', icon: 'üü¢' },
                                'gateway-offline': { color: '#ef4444', label: 'Gateway Offline', icon: 'üî¥' },
                                'feature-changed': { color: '#3b82f6', label: 'Feature Changed', icon: 'üîß' },
                                'firmware-update-status': { color: '#8b5cf6', label: 'Firmware Update', icon: 'üì¶' }
                            };

                            const config = pointEventConfig[eventType] || {
                                color: '#64748b',
                                label: eventType,
                                icon: 'üìå'
                            };

                            timelineData.push({
                                name: config.label,
                                value: [mainCategoryIndex, timestamp.getTime(), endTime.getTime(), pointDuration],
                                itemStyle: {
                                    normal: {
                                        color: config.color,
                                        borderColor: '#ffffff',
                                        borderWidth: 1,
                                        opacity: 0.8
                                    }
                                },
                                eventType: eventType,
                                description: eventDisplayName,
                                icon: config.icon,
                                isPointEvent: true,
                                z: 5 // Render point events above normal events but below S.125-WARMWATER
                            });
                        });
                    }
                });
            });

            // Sort timelineData by z-index so items with higher z render last (on top)
            timelineData.sort((a, b) => (a.z || 1) - (b.z || 1));

            return { data: timelineData, categories };
        }

        // ========================================
        // TIMELINE CONTROLS & PERSISTENCE
        // ========================================

        /**
         * Save timeline filter settings to localStorage
         */
        function saveTimelineFilters() {
            try {
                localStorage.setItem('vicare_timeline_filters', JSON.stringify(globalFilters.timelineTypes));
                // Show success feedback
                const btn = document.getElementById('saveFiltersBtn');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = '‚úì Gespeichert!';
                    btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)';
                    }, 2000);
                }
            } catch (e) {
                console.error('Failed to save timeline filters:', e);
                alert('Fehler beim Speichern der Filter-Einstellungen');
            }
        }

        /**
         * Load timeline filter settings from localStorage
         */
        function loadTimelineFilters() {
            try {
                const saved = localStorage.getItem('vicare_timeline_filters');
                if (saved) {
                    const savedFilters = JSON.parse(saved);
                    // Merge saved filters with defaults (in case new filters were added)
                    globalFilters.timelineTypes = { ...globalFilters.timelineTypes, ...savedFilters };
                    console.log('Loaded timeline filters from localStorage');
                }
            } catch (e) {
                console.error('Failed to load timeline filters:', e);
            }
        }

        /**
         * Reset timeline filters to defaults
         */
        function resetTimelineFilters() {
            if (confirm('M√∂chtest du alle Timeline-Filter auf die Standardwerte zur√ºcksetzen?')) {
                // Reset to all true
                Object.keys(globalFilters.timelineTypes).forEach(key => {
                    globalFilters.timelineTypes[key] = true;
                });
                // Clear from localStorage
                localStorage.removeItem('vicare_timeline_filters');
                // Re-render timeline
                const filteredEvents = applyFilters(allEvents);
                renderTimeline(filteredEvents);
            }
        }

        /**
         * Toggle timeline event type filter
         */
        function toggleTimelineFilter(code) {
            globalFilters.timelineTypes[code] = !globalFilters.timelineTypes[code];
            // Only re-render timeline, not event list
            const filteredEvents = applyFilters(allEvents);
            renderTimeline(filteredEvents);
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        /**
         * Initialize UI elements with globalFilters values
         */
        function initializeUI() {
            document.getElementById('daysSelect').value = globalFilters.days;
            document.getElementById('deviceSelect').value = globalFilters.device;
            document.getElementById('typeFilter').value = globalFilters.type;
            document.getElementById('filterInput').value = globalFilters.search;
        }

        function openDashboard() {
            // Get selected device from filter
            const deviceSelect = document.getElementById('deviceSelect');
            const selectedValue = deviceSelect.value;

            // Function to navigate to dashboard
            const navigateToDashboard = (installationId, deviceId, gatewaySerial) => {
                let url = `/dashboard?installationId=${installationId}`;
                if (deviceId) url += `&deviceId=${deviceId}`;
                if (gatewaySerial) url += `&gatewaySerial=${gatewaySerial}`;
                window.location.href = url;
            };

            // If "all" is selected or no specific device, get first installation
            if (selectedValue === 'all' || !selectedValue) {
                fetch('/api/devices')
                    .then(response => response.json())
                    .then(devicesByInstall => {
                        if (devicesByInstall.length > 0) {
                            const firstInstall = devicesByInstall[0];
                            // Get first heating device
                            const firstDevice = firstInstall.devices && firstInstall.devices.length > 0
                                ? firstInstall.devices[0]
                                : null;

                            navigateToDashboard(
                                firstInstall.installationId,
                                firstDevice ? firstDevice.deviceId : '0',
                                firstDevice ? firstDevice.gatewaySerial : undefined
                            );
                        } else {
                            alert('Keine Installationen gefunden');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading installations:', error);
                        alert('Fehler beim Laden der Installationen');
                    });
            } else {
                // Parse selected device (format: installationId:deviceId or installationId:gatewaySerial:deviceId)
                const parts = selectedValue.split(':');
                if (parts.length === 2) {
                    // Old format: installationId:deviceId
                    navigateToDashboard(parts[0], parts[1]);
                } else if (parts.length === 3) {
                    // New format: installationId:gatewaySerial:deviceId
                    navigateToDashboard(parts[0], parts[2], parts[1]);
                } else {
                    // Fallback: just navigate to dashboard without specific device
                    window.location.href = '/dashboard';
                }
            }
        }

        // ========================================
        // EXPORT FUNCTION
        // ========================================

        /**
         * Export filtered events as JSON file for debugging
         */
        function exportEvents() {
            const filteredEvents = applyFilters(allEvents);

            if (filteredEvents.length === 0) {
                alert('Keine Events zum Exportieren vorhanden');
                return;
            }

            // Create export data with metadata
            const exportData = {
                exportDate: new Date().toISOString(),
                filters: {
                    days: globalFilters.days,
                    device: globalFilters.device,
                    type: globalFilters.type,
                    search: globalFilters.search
                },
                eventCount: filteredEvents.length,
                events: filteredEvents
            };

            // Convert to JSON with pretty formatting
            const jsonString = JSON.stringify(exportData, null, 2);

            // Create blob and download
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');

            // Generate filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.download = `vicare-events-${timestamp}.json`;
            link.href = url;

            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log(`Exported ${filteredEvents.length} events`);
        }

        // Initial load
        window.onload = async () => {
            // Load saved timeline filters from localStorage BEFORE initializing UI
            loadTimelineFilters();
            initializeUI();

            await loadStatus();
            await loadEvents();
        };
    </script>
</body>
</html>
